# ASSIGNEMENT 4 #
print('')
print('                   { FCS Cycle 49 }')
print('')
print('')
print('                    Assignement IV ')
print('                    --------------')
print('')
print('')
#displaying the  menu
print(" Menu: \n 1. Adding a new task to the task manager. \n 2. Getting a task from the queue given a task id. \n 3. Marking the highest priority task as completed and putting it in the task history. \n 4. Displaying all tasks in order of priority. \n 5. Displaying only the tasks that are not completed. \n 6. Displaying the last completed task. \n 7. Exit")
print("")
print("-------------------------------------------")

class Task:

  def __init__(self,task_id : int, description : str, priority :int, completed: bool):
    self.__id = task_id
    self.__description = description
    self.__priority = priority
    self.__completed = completed


  # getting functions #
  def get_id(self):
    return self.__id
  def get_description(self):
    return self.__description
  def get_priority(self):
    return self.__priority
  def get_completed(self):
    return self.__completed

  # setting functions #
  def set_id(self, task_id : int):
    self.__id = task_id
  def set_description(self, description : str):
    self.__description = description
  def set_priority(self, priority : int):
    self.__priority = priority
  def set_completed(self, completed : bool):
    self.__completed = completed

  # setting the string representation #
  def __str__(self):
    return f'{self.__id} , {self.__description},{self.__priority},{self.__completed}'
  
  # starting with priority queue, so we need two classes : one for node and another for the queue #

# class node #
class Node:
  def __init__(self, task : Task):
    self.task = task
    self.next = None

# priority queue #
class PriorityQueue:
  def __init__(self):
    self.__head = None
    self.__size = 0

  # display the queue #
  def display(self):
    if self.__head is None:
      print('The queue is empty')
    else:
      current = self.__head
      while (current.next is not None):
          print(current.task,end="   ------>  ")
          current = current.next

      print(current.task)

################# inserting a new node #################
  def insert(self, task : Task):
    
    node = Node(task)
  # adding to the empty one or last one #
    if (self.__size==0):
      self.__head = node
      self.__size+=1
      print("The task successively added!")
  # new head task #
    elif(node.task.get_priority() > self.__head.task.get_priority()):
        node.next = self.__head
        self.__head = node
        self.__size+=1
        print("The task successively added!")
    # adding in the middle #
    else:
      current = self.__head
      previous = None
      while(current.next is not None and current.task.get_priority()>=node.task.get_priority()):
        previous = current
        current = current.next

      node.next = current
      previous.next = node
      self.__size+=1
      print("The task successively added!")

################# dequeue  #################
  def dequeue(self):
    if self.__size == 0:
      print("The queue is empty")
    elif self.__size == 1:
      self.__head = None
      self.__size -=1
      print("The task successively removed:",self.__head.__task)
    else:
      current = self.__head
      self.__head = self.__head.next
      self.__size -=1
      print("The task successively removed:",current.task)

# we define a stack for completed tasks #
# last completed one will be poped first #
class Stack:

  def __init__(self):
     self.head = None
     self.size = 0
    
  def isEmpty(self):
    return self.head is None
#display the stack#
  def displayStack(self):
    if self.isEmpty():
      print("The stack is empty")
    current = self.head
    while (current is not None):
      print("|" + str(current.task) + "|")
      current = current.next
    print("---")
#push in the stack#
  def push(self, task: Task):
    node_to_add = Node(task)
    node_to_add.next = self.head
    self.head = node_to_add
    self.size += 1
#pop from a stack#
  def pop(self):
    if self.isEmpty():
      print("Cannnot pop from an empty stack")
    else:
      temp = self.head
      self.head = self.head.next
      temp.next = None
      self.size -= 1
      return temp.task